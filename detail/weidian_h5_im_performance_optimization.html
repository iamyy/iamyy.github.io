<!DOCTYPE html><html><head><title>微店 IM 前端性能优化</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>

.note-content  {font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", STHeiti, "Microsoft YaHei", "WenQuanYi Micro Hei", SimSun, Song, sans-serif;}
</style></head><body><div id='preview-contents' class='note-content'>
                        
                    



<h1 id="微店-im-前端性能优化">微店 IM 前端性能优化</h1>

<hr>

<h2 id="1-优化需求">1. 优化需求</h2>

<p>项目使用了 React 技术栈，一次性加载单个大 js 文件严重影响了首屏渲染时间。而且随着需求不断累加，代码量有增无减，按目前的代码实现，白屏问题会越来越严重。为此提出减少白屏时长的优化需求。</p>

<h2 id="2-调研情况">2. 调研情况</h2>

<p>减少白屏时长是一个感官上的描述。根据 IM 项目的技术架构，在程序实现上，前端可以优化的点主要有：</p>

<ul><li>减少首屏加载的 JS 代码量</li>
<li>首屏模块的 JS 执行效率。</li>
</ul>

<p>第一点的优化思路：模块代码懒加载； <br>
第二点的优化思路：模块代码拆分执行</p>

<h2 id="3-思路分析">3. 思路分析</h2>

<h3 id="模块代码懒加载">模块代码懒加载</h3>

<p>这种方案主要是减少网络请求单一大 js 脚本所带来的网络耗时。</p>

<p>可选方案：</p>

<ul><li>webpack code splitting</li>
<li>bundle-loader</li>
</ul>

<p>to be continue…</p>

<h3 id="模块拆分执行">模块拆分执行</h3>

<p>为了解释拆分执行的好处，我们做以下假设和分析。</p>

<h4 id="已知条件">已知条件</h4>

<ol><li rel="1">一个屏幕刷新率为 5 fps 的电脑；</li>
<li rel="2">一个页面，其中包含 4 个内容版块从上到下排列 m1, m2, m3, m4，均出现在首屏；</li>
<li rel="3">每个内容版块的初始化 js 脚本之行时间为 150ms。</li>
</ol>

<h4 id="问题">问题</h4>

<p>如何执行可以尽可能的减少白屏时间？</p>

<h4 id="分析">分析</h4>



<h5 id="初步分析">初步分析</h5>

<p>由条件 1 可知：</p>

<ul><li>屏幕每 1000 / 5 = 200 ms 刷新一次；</li>
<li>浏览器在这台电脑上每 200 ms 有一次机会将更新后的画面展示给用户的机会，错过了就要等下一次设备屏幕刷新时间点。（屏幕刷新时间点：200ms, 400ms, 600ms, 800ms, 1000ms ）</li>
</ul>

<p>由条件 2 可知：</p>

<ul><li>浏览器主线程除了要执行 js，还要做样式计算、布局，绘制的工作，如果 js 执行时间过长，会阻塞页面的渲染；</li>
<li>如果一次性执行 m1, m2, m3, m4 的初始化代码，要在浏览器主线程上消耗 150 * 4 = 600 ms 的时间，再加上主线程的其他任务耗时，浏览器渲染工作就一定超过了 600 ms。也就是说，用户要等到第 800 ms 的刷新节点才能看到内容，即白屏时长至少为 800 ms；</li>
</ul>

<h5 id="进一步分析">进一步分析：</h5>

<p>浏览器渲染页面要经过以下关键流程： <br>
Javascript &gt; Style &gt; Layout &gt; Paint &gt; Composite</p>

<p>执行完 Composite  就算是一次页面渲染。</p>

<p>也就是说在第 1 个刷新节点 ( 200ms ) 到来之前最好能完成至少一次这个流程，用户就能更早的看到页面有内容展示。</p>

<p>按照这个思路，我们可以得到如下方案：</p>

<p>优先执行 m_1 的初始化代码（150ms），就有机会在 200 ms 那个刷新节点呈现出 m1 的内容。随后在下一个刷新节点到来之前再执行 m2 的初始化代码。以此类推，最终也是在 800 ms 前完成所有模块的渲染工作。</p>

<p>代码实现上（伪代码 1）：</p>

<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">var</span> modList = [ m1, m2, m3, m4 ];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadMod</span>(<span class="hljs-params"></span>) </span>{<br>  <span class="hljs-keyword">var</span> m = modList.pop();<br><br>  <span class="hljs-keyword">if</span>( modList.length &gt; <span class="hljs-number">0</span> ) {<br>    setTimeout( loadMod, <span class="hljs-number">200</span>);<br>  }<br><br>  m.load();<br>}<br>loadMod();<br></code></pre>

<p>然而 setTimeout 的执行时机是无法保证的，比如可能在 195 ms 时执行，那么在 200 ms 的刷新点时 m2 的 js 代码阻塞了浏览器渲染，因此丢失 1 帧，没能达到我们的方案要求。</p>

<p>改进实现（伪代码 2）：</p>



<pre class="prettyprint hljs-dark"><code class="language-javascript hljs"><span class="hljs-keyword">var</span> modList = [ m1, m2, m3, m4 ];<br>requestAnimationFrame( loadMod );<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadMod</span>(<span class="hljs-params"></span>) </span>{<br>  <span class="hljs-keyword">var</span> m = modList.pop();<br><br>  m.load();<br><br>  <span class="hljs-keyword">if</span>( modList.length &gt; <span class="hljs-number">0</span> ) {<br>    requestAnimationFrame( loadMod );<br>  }<br>}<br></code></pre>

<p>requestAnimationFrame 是一个浏览器全局方法，它保证了在下一次重绘前（异步）执行传给它的第一个函数参数（ 本例中的 loadMod ）</p>

<p>requestAnimationFrame 的异步时长 == 1000 / 设备刷新率 ? <br>
通过以下代码可知：</p>

<pre class="prettyprint hljs-dark"><code class="hljs javascript"><span class="hljs-keyword">var</span> lastFrameTime;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"> time </span>) </span>{<br>  <span class="hljs-keyword">if</span>( lastFrameTime ) {<br>    <span class="hljs-built_in">console</span>.log( time - lastFrameTime );<br>  }<br>  lastFrameTime = time;<br>  requestAnimationFrame( a );<br>}<br>requestAnimationFrame( a );<br></code></pre>

<p>以上分析都是基于 5 fps，而实际设备的刷新率一般为 60 fps。</p>

<p>通过以上分析可知，在更细的代码粒度上，我们可以通过这种 “拆分执行” 的方式优化页面执行效率。</p></div></body></html>